Here's how you can abstract this code to make it more unit-testable:

## 1. Create a Configuration Class

```python
from dataclasses import dataclass
from os import environ
from typing import Optional

@dataclass
class Config:
    rest_api_name: str
    rest_api_port: str

    @property
    def rest_api_url(self) -> str:
        return f"http://{self.rest_api_name}:{self.rest_api_port}"

    @classmethod
    def from_env(cls) -> 'Config':
        api_name = environ.get('REST_API_NAME')
        api_port = environ.get('REST_API_PORT')

        if not api_name:
            raise ValueError("REST_API_NAME environment variable is required")
        if not api_port:
            raise ValueError("REST_API_PORT environment variable is required")

        return cls(rest_api_name=api_name, rest_api_port=api_port)
```

## 2. Create an HTTP Client Interface

```python
from abc import ABC, abstractmethod
from typing import Tuple, Any

class HttpClient(ABC):
    @abstractmethod
    def post(self, url: str, json_data: dict) -> Tuple[int, Any]:
        pass

    @abstractmethod
    def get(self, url: str, params: dict = None) -> Tuple[int, Any]:
        pass

class RequestsHttpClient(HttpClient):
    def __init__(self, max_retries: int = 3, retry_delay: int = 5, long_delay: int = 60):
        self.max_retries = max_retries
        self.retry_delay = retry_delay
        self.long_delay = long_delay

    def post(self, url: str, json_data: dict) -> Tuple[int, Any]:
        return self._make_request('post', url, json_data)

    def get(self, url: str, params: dict = None) -> Tuple[int, Any]:
        return self._make_request('get', url, params)

    def _make_request(self, method: str, url: str, data: dict = None) -> Tuple[int, Any]:
        import requests
        from time import sleep

        for i in range(self.max_retries):
            for j in range(5):
                try:
                    if method == 'post':
                        response = requests.post(url, json=data)
                    elif method == 'get':
                        response = requests.get(url, params=data)
                    else:
                        return 405, f"'{method}' is not an allowed method."

                except requests.exceptions.RequestException as e:
                    print(f"Request exception: {e}")
                    return 0, e

                if response.status_code == 200:
                    return response.status_code, response.json().get('data')
                if response.status_code == 404:
                    return response.status_code, response.json().get('message')

                print(f"ERROR: Unable to contact database on attempt #{i * 5 + j + 1}")
                print(f"ERROR {response.status_code}, {response.json().get('message')}")
                sleep(self.retry_delay)

            print(f"ERROR: Failed to contact database {url}, pausing.")
            sleep(self.long_delay)

        exit(69)  # Service unavailable
```

## 3. Create a Validator Class

```python
class HashInfoValidator:
    VALID_KEYS = {'path', 'current_hash', 'current_dtg_latest', 'dirs', 'files', 'links'}
    REQUIRED_KEYS = {'current_hash', 'current_dtg_latest'}

    def validate(self, hash_info: dict) -> list:
        """Validate hash_info and return list of validation errors."""
        errors = []

        for path, item_data in hash_info.items():
            item_errors = self._validate_item(path, item_data)
            errors.extend(item_errors)

        return errors

    def _validate_item(self, path: str, item_data: dict) -> list:
        errors = []

        # Check for invalid keys
        for key in item_data.keys():
            if key not in self.VALID_KEYS:
                errors.append(f"Invalid key '{key}' in item '{path}'")

        # Check for missing required keys
        for key in self.REQUIRED_KEYS:
            if key not in item_data:
                errors.append(f"Missing required key '{key}' in item '{path}'")

        return errors
```

## 4. Refactor the Main Service Class

```python
class RestConnector:
    def __init__(self, config: Config, http_client: HttpClient, validator: HashInfoValidator = None):
        self.config = config
        self.http_client = http_client
        self.validator = validator or HashInfoValidator()

    def put_hashtable(self, hash_info: dict) -> dict[str, set]:
        # Validate input
        validation_errors = self.validator.validate(hash_info)
        if validation_errors:
            for error in validation_errors:
                print(f"Validation error: {error}")

        changes = []

        for path, item_data in hash_info.items():
            # Skip invalid items
            if self._has_validation_errors(path, item_data):
                continue

            code, update = self._db_put("hashtable", {
                'path': path,
                'current_hash': item_data['current_hash'],
                'current_dtg_latest': item_data['current_dtg_latest'],
                'dirs': item_data.get('dirs'),
                'files': item_data.get('files'),
                'links': item_data.get('links')
            })

            if code != 200:
                print(f"ERROR: REST API returned {code}: {update}")
                continue

            changes.append(update)

        return self._process_changes(changes)

    def get_single_hash(self, path: str) -> str | None:
        response = self._db_get("hash", path)
        return self._process_response(response)

    def get_hashtable(self, path: str) -> dict | None:
        response = self._db_get("hashtable", path)
        return self._process_response(response)

    def get_oldest_updates(self, root_path: str, percent: int = 10) -> list[str]:
        base_response = self.get_hashtable(root_path)

        if not base_response or not base_response.get('current_dtg_latest'):
            print("STATUS: Local database is empty, requesting full hash")
            return [root_path]

        dirs = base_response.get('dirs', [])
        if not dirs:
            print("STATUS: no child directories in database, requesting full hash")
            return [root_path]

        # Build and sort by timestamp
        dir_timestamps = [(self.get_single_timestamp(directory), directory) for directory in dirs]
        ordered_dirs = [directory for _, directory in sorted(dir_timestamps)]

        # Calculate number of directories to return
        update_num = max(1, int(len(dirs) * percent / 100))
        update_num = min(update_num, len(dirs))

        print(f"Returning {update_num} directories for update")
        return ordered_dirs[:update_num]

    def get_single_timestamp(self, path: str) -> float | None:
        response = self._db_get("timestamp", path)
        return self._process_response(response)

    def get_priority_updates(self) -> str | None:
        response = self._db_get('priority')
        return self._process_response(response)

    def _has_validation_errors(self, path: str, item_data: dict) -> bool:
        errors = self.validator._validate_item(path, item_data)
        if errors:
            for error in errors:
                print(f"ERROR: {error}")
            return True
        return False

    def _process_changes(self, changes: list) -> dict[str, set]:
        sorted_changes = {'Created': set(), 'Deleted': set(), 'Modified': set()}
        for change in changes:
            for key in sorted_changes.keys():
                if key in change:
                    sorted_changes[key].update(set(change[key]))
        return sorted_changes

    def _process_response(self, response: Tuple[int, Any]) -> Any:
        code, content = response
        return content if code == 200 else None

    def _db_put(self, endpoint: str, request: dict) -> Tuple[int, Any]:
        url = f"{self.config.rest_api_url}/{endpoint}"
        return self.http_client.post(url, request)

    def _db_get(self, endpoint: str, params: dict = None) -> Tuple[int, Any]:
        url = f"{self.config.rest_api_url}/{endpoint}"
        return self.http_client.get(url, params)
```

## 5. Updated Bootstrap Code

```python
# bootstrap.py
def create_rest_connector() -> RestConnector:
    try:
        config = Config.from_env()
        http_client = RequestsHttpClient()
        validator = HashInfoValidator()
        return RestConnector(config, http_client, validator)
    except ValueError as e:
        print(f"ERROR: Unable to bootstrap rest_connector: {e}")
        exit(78)  # Configuration error

# Usage
rest_connector = create_rest_connector()
```

## 6. Example Unit Tests

```python
import unittest
from unittest.mock import Mock, patch

class TestRestConnector(unittest.TestCase):
    def setUp(self):
        self.config = Config("test-api", "8080")
        self.mock_http_client = Mock(spec=HttpClient)
        self.validator = HashInfoValidator()
        self.rest_connector = RestConnector(self.config, self.mock_http_client, self.validator)

    def test_get_single_hash_success(self):
        # Arrange
        self.mock_http_client.get.return_value = (200, "test_hash")

        # Act
        result = self.rest_connector.get_single_hash("/test/path")

        # Assert
        self.assertEqual(result, "test_hash")
        self.mock_http_client.get.assert_called_once_with("http://test-api:8080/hash", "/test/path")

    def test_get_single_hash_not_found(self):
        # Arrange
        self.mock_http_client.get.return_value = (404, "Not found")

        # Act
        result = self.rest_connector.get_single_hash("/test/path")

        # Assert
        self.assertIsNone(result)

    def test_put_hashtable_validation_error(self):
        # Arrange
        invalid_hash_info = {
            "/test/path": {
                "invalid_key": "value",
                "current_hash": "hash123"
                # Missing required 'current_dtg_latest'
            }
        }

        # Act
        with patch('builtins.print') as mock_print:
            result = self.rest_connector.put_hashtable(invalid_hash_info)

        # Assert
        self.assertEqual(result, {'Created': set(), 'Deleted': set(), 'Modified': set()})
        mock_print.assert_called()

class TestHashInfoValidator(unittest.TestCase):
    def setUp(self):
        self.validator = HashInfoValidator()

    def test_valid_hash_info(self):
        valid_data = {
            "/test": {
                "current_hash": "hash123",
                "current_dtg_latest": "2023-01-01",
                "dirs": ["dir1", "dir2"]
            }
        }

        errors = self.validator.validate(valid_data)
        self.assertEqual(errors, [])

    def test_missing_required_key(self):
        invalid_data = {
            "/test": {
                "current_hash": "hash123"
                # Missing 'current_dtg_latest'
            }
        }

        errors = self.validator.validate(invalid_data)
        self.assertIn("Missing required key 'current_dtg_latest' in item '/test'", errors)
```

## Key Benefits of This Refactoring:

1. **Dependency Injection**: The `RestConnector` now accepts its dependencies, making it easy to mock for testing
2. **Single Responsibility**: Each class has a clear, focused purpose
3. **Testable**: All external dependencies (HTTP requests, environment variables) can be mocked
4. **Configuration Management**: Environment variables are handled in one place
5. **Validation Logic**: Separated into its own testable class
6. **Error Handling**: More structured and testable
7. **Maintainable**: Easier to modify individual components without affecting others

This structure makes it much easier to write comprehensive unit tests for each component independently.