I'll help you design a Kubernetes deployment for your microservices architecture. Based on your requirements, here's a comprehensive solution:

## 1. Scheduled Container (CronJob)

```yaml
# cronjob.yaml
apiVersion: batch/v1
kind: CronJob
metadata:
  name: hourly-task
  namespace: your-app
spec:
  schedule: "0 * * * *"  # Every hour
  jobTemplate:
    spec:
      template:
        spec:
          restartPolicy: OnFailure
          containers:
          - name: scheduled-task
            image: your-registry/scheduled-task:latest
            env:
            - name: API_URL
              value: "http://rest-api-service:8080"
            resources:
              requests:
                memory: "128Mi"
                cpu: "100m"
              limits:
                memory: "256Mi"
                cpu: "200m"
          # Clean up completed jobs
      successfulJobsHistoryLimit: 3
      failedJobsHistoryLimit: 1
```

## 2. Database Container (StatefulSet)

```yaml
# database.yaml
apiVersion: apps/v1
kind: StatefulSet
metadata:
  name: database
  namespace: your-app
spec:
  serviceName: database-service
  replicas: 1
  selector:
    matchLabels:
      app: database
  template:
    metadata:
      labels:
        app: database
    spec:
      containers:
      - name: database
        image: postgres:15  # or your preferred database
        ports:
        - containerPort: 5432
        env:
        - name: POSTGRES_DB
          value: "appdb"
        - name: POSTGRES_USER
          valueFrom:
            secretKeyRef:
              name: db-secret
              key: username
        - name: POSTGRES_PASSWORD
          valueFrom:
            secretKeyRef:
              name: db-secret
              key: password
        volumeMounts:
        - name: database-storage
          mountPath: /var/lib/postgresql/data
        resources:
          requests:
            memory: "512Mi"
            cpu: "250m"
          limits:
            memory: "1Gi"
            cpu: "500m"
  volumeClaimTemplates:
  - metadata:
      name: database-storage
    spec:
      accessModes: ["ReadWriteOnce"]
      resources:
        requests:
          storage: 10Gi

---
apiVersion: v1
kind: Service
metadata:
  name: database-service
  namespace: your-app
spec:
  selector:
    app: database
  ports:
  - port: 5432
    targetPort: 5432
  clusterIP: None  # Headless service for StatefulSet
```

## 3. REST API Container (Deployment)

```yaml
# rest-api.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: rest-api
  namespace: your-app
spec:
  replicas: 2
  selector:
    matchLabels:
      app: rest-api
  template:
    metadata:
      labels:
        app: rest-api
    spec:
      containers:
      - name: rest-api
        image: your-registry/rest-api:latest
        ports:
        - containerPort: 8080
        env:
        - name: DB_HOST
          value: "database-service"
        - name: DB_PORT
          value: "5432"
        - name: DB_NAME
          value: "appdb"
        - name: DB_USER
          valueFrom:
            secretKeyRef:
              name: db-secret
              key: username
        - name: DB_PASSWORD
          valueFrom:
            secretKeyRef:
              name: db-secret
              key: password
        readinessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 30
          periodSeconds: 10
        livenessProbe:
          httpGet:
            path: /health
            port: 8080
          initialDelaySeconds: 60
          periodSeconds: 30
        resources:
          requests:
            memory: "256Mi"
            cpu: "200m"
          limits:
            memory: "512Mi"
            cpu: "400m"

---
apiVersion: v1
kind: Service
metadata:
  name: rest-api-service
  namespace: your-app
spec:
  selector:
    app: rest-api
  ports:
  - port: 8080
    targetPort: 8080
  type: ClusterIP
```

## 4. NGINX Container with Location-Based Deployment

### Base NGINX Deployment
```yaml
# nginx-base.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-proxy
  namespace: your-app
spec:
  replicas: 1
  selector:
    matchLabels:
      app: nginx-proxy
  template:
    metadata:
      labels:
        app: nginx-proxy
    spec:
      # Node selector for location-based deployment
      nodeSelector:
        location: "public"  # Only deploy on nodes labeled with location=public
      containers:
      - name: nginx
        image: nginx:alpine
        ports:
        - containerPort: 80
        - containerPort: 443
        volumeMounts:
        - name: nginx-config
          mountPath: /etc/nginx/conf.d
        resources:
          requests:
            memory: "64Mi"
            cpu: "50m"
          limits:
            memory: "128Mi"
            cpu: "100m"
      volumes:
      - name: nginx-config
        configMap:
          name: nginx-config

---
apiVersion: v1
kind: Service
metadata:
  name: nginx-service
  namespace: your-app
spec:
  selector:
    app: nginx-proxy
  ports:
  - name: http
    port: 80
    targetPort: 80
  - name: https
    port: 443
    targetPort: 443
  type: LoadBalancer  # or NodePort depending on your setup
```

### NGINX Configuration
```yaml
# nginx-config.yaml
apiVersion: v1
kind: ConfigMap
metadata:
  name: nginx-config
  namespace: your-app
data:
  default.conf: |
    upstream api_backend {
        server rest-api-service:8080;
    }

    server {
        listen 80;
        server_name _;

        # Health check endpoint
        location /nginx-health {
            access_log off;
            return 200 "healthy\n";
            add_header Content-Type text/plain;
        }

        # Proxy to REST API
        location /api/ {
            proxy_pass http://api_backend/;
            proxy_set_header Host $host;
            proxy_set_header X-Real-IP $remote_addr;
            proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
            proxy_set_header X-Forwarded-Proto $scheme;

            # CORS headers if needed
            add_header Access-Control-Allow-Origin *;
            add_header Access-Control-Allow-Methods "GET, POST, PUT, DELETE, OPTIONS";
            add_header Access-Control-Allow-Headers "Authorization, Content-Type";
        }

        # Handle preflight requests
        location /api/ {
            if ($request_method = 'OPTIONS') {
                add_header Access-Control-Allow-Origin *;
                add_header Access-Control-Allow-Methods "GET, POST, PUT, DELETE, OPTIONS";
                add_header Access-Control-Allow-Headers "Authorization, Content-Type";
                return 204;
            }
        }
    }
```

## 5. Location-Based NGINX Deployment Strategy

### Option A: Node Selectors
Label your nodes based on location:
```bash
# Label nodes that need NGINX
kubectl label nodes node-1 location=public
kubectl label nodes node-2 location=public

# Nodes that don't need NGINX
kubectl label nodes node-3 location=internal
```

### Option B: Multiple NGINX Deployments per Location
```yaml
# nginx-location-us.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-proxy-us
  namespace: your-app
spec:
  replicas: 2
  selector:
    matchLabels:
      app: nginx-proxy
      location: us
  template:
    metadata:
      labels:
        app: nginx-proxy
        location: us
    spec:
      nodeSelector:
        region: us-east
      # ... rest of the container spec

---
# nginx-location-eu.yaml
apiVersion: apps/v1
kind: Deployment
metadata:
  name: nginx-proxy-eu
  namespace: your-app
spec:
  replicas: 1
  selector:
    matchLabels:
      app: nginx-proxy
      location: eu
  template:
    metadata:
      labels:
        app: nginx-proxy
        location: eu
    spec:
      nodeSelector:
        region: eu-west
      # ... rest of the container spec
```

## 6. Database Secret
```yaml
# db-secret.yaml
apiVersion: v1
kind: Secret
metadata:
  name: db-secret
  namespace: your-app
type: Opaque
data:
  username: <base64-encoded-username>
  password: <base64-encoded-password>
```

## 7. Namespace
```yaml
# namespace.yaml
apiVersion: v1
kind: Namespace
metadata:
  name: your-app
```

## 8. Deployment Script
```bash
#!/bin/bash
# deploy.sh

# Create namespace
kubectl apply -f namespace.yaml

# Create secrets
kubectl apply -f db-secret.yaml

# Deploy database
kubectl apply -f database.yaml

# Wait for database to be ready
kubectl wait --for=condition=ready pod -l app=database -n your-app --timeout=300s

# Deploy REST API
kubectl apply -f rest-api.yaml

# Wait for API to be ready
kubectl wait --for=condition=ready pod -l app=rest-api -n your-app --timeout=300s

# Deploy NGINX (only on nodes that need it)
kubectl apply -f nginx-config.yaml
kubectl apply -f nginx-base.yaml

# Deploy CronJob
kubectl apply -f cronjob.yaml

echo "Deployment complete!"
```

## Key Features:

1. **Scheduled Container**: Uses CronJob for hourly execution
2. **Database**: StatefulSet with persistent storage
3. **REST API**: Deployment with health checks and service discovery
4. **Location-based NGINX**: Uses node selectors to deploy only where needed
5. **Security**: Uses Secrets for database credentials
6. **Monitoring**: Includes health checks and resource limits
7. **Scalability**: API can be scaled independently

This setup provides a robust, scalable microservices architecture with location-aware NGINX deployment.